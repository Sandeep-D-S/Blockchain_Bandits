# -*- coding: utf-8 -*-
"""BlockChain_Bandits.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1A2WNrYxo0ZYFqcoH1ReIUevsvNCq1OtR
"""

!pip install eth-keys

!pip install eth-hash[pycryptodome]

from eth_keys import keys
from eth_utils import to_checksum_address

# Custom private key (replace with your own 32-byte hex key)
private_key_hex = "2".zfill(64)

# Convert the private key from hex to bytes
private_key_bytes = bytes.fromhex(private_key_hex)

# Generate the private key object
private_key = keys.PrivateKey(private_key_bytes)

# Get the corresponding public key
public_key = private_key.public_key

# Generate the Ethereum address
eth_address = public_key.to_address()

# Convert to checksum address for better readability
checksum_address = to_checksum_address(eth_address)

# Print results
print(f"Private Key: {private_key}")
print(f"Public Key: {public_key}")
print(f"Ethereum Address: {checksum_address}")

!pip install ecdsa

from ecdsa import SigningKey, SECP256k1

# Generate private key
private_key = SigningKey.generate(curve=SECP256k1)

# Generate public key
public_key = private_key.verifying_key

# Display the keys
print("Private Key:", private_key.to_string().hex())
print("Public Key:", public_key.to_string().hex())

!pip install eth-hash

!pip install cryptography

from cryptography.hazmat.primitives.asymmetric import ec
from cryptography.hazmat.primitives import serialization

# Select the elliptic curve group
curve_group = ec.SECP256R1()  # You can change this to another curve

# Generate private key
private_key = ec.generate_private_key(curve_group)

# Get the public key
public_key = private_key.public_key()

# Serialize and display private key
private_key_pem = private_key.private_bytes(
    encoding=serialization.Encoding.PEM,
    format=serialization.PrivateFormat.TraditionalOpenSSL,
    encryption_algorithm=serialization.NoEncryption()
)

# Serialize and display public key
public_key_pem = public_key.public_bytes(
    encoding=serialization.Encoding.PEM,
    format=serialization.PublicFormat.SubjectPublicKeyInfo
)

print("Private Key:\n", private_key_pem.decode())
print("\nPublic Key:\n", public_key_pem.decode())

from ecdsa import SigningKey, SECP256k1
import hashlib
from eth_hash.auto import keccak

# 1. Generate a Private Key (256-bit random value)
private_key = SigningKey.generate(curve=SECP256k1).to_string().hex()
print("Private Key:", private_key)

# 2. Derive Public Key (Uncompressed)
signing_key = SigningKey.from_string(bytes.fromhex(private_key), curve=SECP256k1)
verifying_key = signing_key.verifying_key
public_key = b'\x04' + verifying_key.to_string()
public_key_hex = public_key.hex()
print("Public Key:", public_key_hex)

# 3. Compute Ethereum Address (Keccak-256 of Public Key, last 20 bytes)
eth_address = keccak(public_key[1:])[-20:].hex()

# 4. Format the address with "0x"
eth_address = "0x" + eth_address

print("Ethereum Address:", eth_address)

# 5. Provide the Etherscan search URL
print("\nSearch this address on Etherscan: https://etherscan.io/address/" + eth_address)

!pip install ecdsa eth-hash concurrent.futures

!pip install requests eth-hash

import ecdsa
import hashlib
from eth_hash.auto import keccak
from concurrent.futures import ThreadPoolExecutor

# Function to generate Ethereum address from private key
def generate_eth_address(_): # Added '_' as a placeholder for the unused argument
    # 1. Generate a Private Key (SECP256K1)
    private_key = ecdsa.SigningKey.generate(curve=ecdsa.SECP256k1).to_string().hex()

    # 2. Generate Public Key (Uncompressed)
    signing_key = ecdsa.SigningKey.from_string(bytes.fromhex(private_key), curve=ecdsa.SECP256k1)
    verifying_key = signing_key.verifying_key
    public_key = b'\x04' + verifying_key.to_string()  # Uncompressed key

    # 3. Compute Ethereum Address (Keccak-256 of Public Key, last 20 bytes)
    eth_address = keccak(public_key[1:])[-20:].hex()
    eth_address = "0x" + eth_address

    return private_key, eth_address

# Function to generate multiple addresses in parallel
def generate_multiple_addresses(count):
    with ThreadPoolExecutor() as executor:
        results = list(executor.map(generate_eth_address, range(count)))

    return results

# Generate multiple addresses
num_addresses = int(input("Enter number of addresses to generate: "))
addresses = generate_multiple_addresses(num_addresses)

# Display results
print("\nGenerated Ethereum Addresses:")
for i, (priv_key, eth_address) in enumerate(addresses):
    print(f"\nAddress {i+1}: {eth_address}")
    print(f"Private Key: {priv_key}")
    print(f"Check on Etherscan: https://etherscan.io/address/{eth_address}")

import requests
import ecdsa
from eth_hash.auto import keccak
from bs4 import BeautifulSoup

# Function to generate Ethereum address
def generate_eth_address():
    private_key = ecdsa.SigningKey.generate(curve=ecdsa.SECP256k1).to_string().hex()

    signing_key = ecdsa.SigningKey.from_string(bytes.fromhex(private_key), curve=ecdsa.SECP256k1)
    verifying_key = signing_key.verifying_key
    public_key = b'\x04' + verifying_key.to_string()

    eth_address = keccak(public_key[1:])[-20:].hex()
    eth_address = "0x" + eth_address

    return private_key, eth_address

# Function to scrape Etherscan and check balance
def check_balance_no_api(address):
    url = f"https://etherscan.io/address/{address}"
    headers = {"User-Agent": "Mozilla/5.0"}

    response = requests.get(url, headers=headers)
    soup = BeautifulSoup(response.text, "html.parser")

    # Find the balance section
    balance_tag = soup.find("div", class_="card-body")

    if balance_tag:
        balance_text = balance_tag.text.strip()
        return f"✅ Address {address} exists! Balance: {balance_text}"
    else:
        return f"❌ Address {address} is not found on Etherscan."

# Generate an address and check its balance
private_key, eth_address = generate_eth_address()
print(f"Generated Address: {eth_address}")
print(f"Private Key: {private_key}")
print(f"Checking on Etherscan: {check_balance_no_api(eth_address)}")

